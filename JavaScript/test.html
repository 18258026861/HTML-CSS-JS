<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script id="猜拳游戏" type="text/html">
    var player,com;
    com = parseInt(Math.random()*3);
    console.log(com);
    player = window.prompt("请出拳，0为剪刀，1为石头，2为布");
    if(player<0||player>2){
    window.confirm("请出拳，0为剪刀，1为石头，2为布");
    }else{
    if((0 == player && 2 == com)||(1 == player && 0 == com)||(2 == player && 1 == com))
    {
    alert("恭喜你赢了");
    }
    else if((0 == player && 0 == com)||(1 == player && 1 == com)||(2 == player && 2 == com))
    {
    alert("平局");
    }
    else
    {
    alert("对不起，你输了");
    }
    }

</script>
<script type="text/html">
    var array1 = new Array(1);
    var array2 = [];
    array2.length = 20;
    if(array1 = array2)
    {
    alert("相同");
    }

</script>
<script id="小动物叫声" type="text/html">
    function jiaoShen(a) {
    switch(a){
    case 'tiger' :
    console.log('hou');
    break;
    case 'monkey' :
    console.log('ao');
    break;
    case 'dog' :
    console.log('wang');
    break;
    }
    }
    var a ;
    a = window.prompt("请出拳，0为剪刀，1为石头，2为布");
    jiaoShen(a);
</script>
<script id="输入数字反向，翻译成汉字" type="text/html">
    function reverse() {
    var num = window.prompt("输入数字");
    //console.log(num);
    var str='';
    for(var i=num.length-1;i>=0;i--) {

    str +=exchange(num[i]);
    }
    console.log(str);
    }
    function exchange(target) {
    switch (target) {
    case '1' :
    return '一';
    case '2' :
    return '二';
    }
    }

    reverse();
</script>
<script id="n的阶乘" type="text/html">
    function jc(n) {
    if(n == 1){
    return 1;}
    else
    return n * jc(n-1);
    }
    var n = prompt("输入阶乘n");
    console.log(jc(n));

</script>
<script id="斐波那契数列" type="text/html">
    function f(n) {
    if(n == 1){
    return 1;
    }
    else if(n ==2){
    return 1;
    }else{
    return f(n-1) + f(n-2);
    document.write(f(n-1));
    }
    }
    var n = window.prompt("输入第几个数")
    f(n);
    console.log(f(n));
</script>
<script id="预编译" type="text/html"  >
    //在编译之前先扫描一遍看有没有语法错误
    //预编译
    //函数声明整体提升--会把函数总是提升到最前面,如下面的例子，可以把函数放到函数声明之前
    javase.test();
    function javase.test() {
    }
    //变量声明提升--会把变量声明提到前面，但是赋值不行。



    //变量未经声明就赋值，即暗示全局变量。全局对象（window）所有
    a = 123;
    window.a = 123;
    var  a = b = 123;//这时候b当做了暗示变量因为从右往左赋值123赋给b时b还没有声明，再把b赋给a时先声明啊再赋值
    console.log(a);  //undefined
    console.log(b); //123

    //声明的全局变量为window的属性，window就是全局的域
    var  a = 123;  //window.a = 123;
    var b = 234;    //window b = 234;
    //作用域-----------------------------------------------------------------------
    //1创建AO activation object（作用域）
    //2找函数的形参和变量声明,将变量和形参作为AO的属性名，值为undefined
    //3将实参和形参统一，把1代入
    //4在函数体里面找函数声明，值赋予函数体
    // AO{
    //     a : function a(){},  //将实参和形参统一，把1代入     //再把函数声明function a(){}代入
    //     b : undefined,
    //     d : function d() {}  //再把函数声明functiond(){}代入
    // }//即函数声明是提升到最前面的，相当于把后面的function语句提到了第一，之后之后遇到这句语句就直接跳过了

    function fn(a) {
    console.log(a);     // 第一次的结果为function a() {}
    var a = 123;                //这时a = 123覆盖了function
    console.log(a);             //a = 123
    function a() {}     //函数声明 //这句话在预编译时已经提到了前面，所以现在跳过了
    console.log(a);             //a = 123
    var b = function () {}  //函数表达式 //b = function
    console.log(b);                 //b = function
    function d() {}     //函数声明
    }
    fn(1);
    //第一二步，在函数中确认变量有哪些啊，a,b值为undefined
    //     AO{
    //         a : undefined,
    //         b : undefined,
    //     }
    //     //第三步，实参形参相统一，a的实参为1
    //     AO{
    //         a : 1,
    //         b : undefined,
    //     }
    //     //第四步,在函数体里面找函数声明，值赋予函数体，在函数中找到了函数d，把函数声明赋值给a和d
    //     AO{
    //         a : function a() {},
    //         b : undefined,
    //         d : function d() {}
    //     }
    //当执行到a = 123时， a的值变成123，执行到b时，b的值变成了function

    //全局预编译
    //1.生成GO对象，GO == window
    //
    //
    //
</script >
<script id="预编译例子" type="text/html">
    //例子1------------------------------------------------------------------------------
    function javase.test(a,b) {
    console.log(a);     //输出a=1
    c = 0;           //c = 0
    var c;
    a = 3;          //a = 3
    b = 2;          //b = 2
    console.log(b); //输出b=2
    function b() {} //b = 2
    function d() {} //d = function d(){}
    console.log(b); //输出b=2
    }

    javase.test(1);
    // AO{
    //     a : 1,
    //         b : function b() {},
    //     c : undefined,
    //         d : function d() {}
    // }
    //例子2----------------------------------------------------------------------------
    function javase.test(a,b) {
    console.log(a);     //输出a = function a(){}
    console.log(b);     //输出undefined
    var b = 234;         //b = 234
    console.log(b);     //输出b = 234
    a = 123;            //a = 123
    console.log(a);      //输出a = 123
    function a() {}     //函数声明提升
    var a;
    b = 234;
    var b = function () {}  //！！这是函数表达式，不是函数声明，第四步没用  //b = function (){}
    console.log(a);        //输出a = 123
    console.log(b);         //输出b = function() {}
    }
    javase.test(1);

    // AO{
    //     a : function a() {},
    //     b : undefined
    // }
    //例子3----------------------------------------------------------------------------
    console.log(javase.test);   //输出function javase.test(){}
    function javase.test() {
    console.log(javase.test);//输出function javase.test(){}
    var javase.test = 234; //javase.test = 234;
    console.log(javase.test); //输出test = 234;
    function javase.test() {
    }
    }
    javase.test(1);//执行到这时先预编译AO
    var javase.test = 123; //javase.test = 123

    // GO{
    //     javase.test : function () {}
    // }
    // AO{
    //     javase.test : function () {
    //
    //     }
    // }
    //例子4----------------------------------------------------------------------------
    var global = 100;   //global = 100

    function fn() {
    console.log(global); //函数内部没有，找全局  //输出100
    }
    fn();

    // GO{
    //     global : undefined,
    //     fn : function () {}
    // }
    // AO{
    //     空
    // }
    //例子5----------------------------------------------------------------------------
    global = 100;       //global = 100
    function fn(){
    console.log(global); //！！自己内部有就先找自己的，不引用外部   //输出undefined
    global = 200;       //global = 200
    console.log(global);    //输出global = 200
    var global = 300;       //global = 300
    }
    fn();
    var global;

    // GO{
    //     global : undefined,
    //     fn : function (){}
    // }
    // AO{
    //     global : undefined,
    // }
    //例子6----------------------------------------------------------------------------
    function javase.test(){
    console.log(b); //undefined
    if(a){          //if不影响声明变量
    var b = 100;
    }
    c = 234;    //没有声明，那么这个值变成全局的属性    //c =234
    console.log(c); //输出c = 234
    }
    var a;
    javase.test()
    a = 10;     //a = 10
    console.log(c); // 输出c = 234

    // GO{
    //     a : undefined，
    //     c : undefined
    // }
    // AO{
    //     a : undefined,
    //     b : undefined
    // }
    //百度面试题例1----------------------------------------------------------------------------
    function bar() {
    return foo;     //function () {}
    foo = 10;
    function foo() {}
    var foo = 11;
    }
    console.log(bar());// 输出function () {}
    // AO{
    //     foo : function foo() {}
    // }
    //百度面试题例2----------------------------------------------------------------------------
    console.log(bar());//输出11
    function bar() {
    foo =10;  // foo = 10
    function foo() {}
    var foo = 11;   //foo = 11
    return foo; //foo = 11
    }
    // AO{
    //     foo : function foo() {}
    // }
    //例子7----------------------------------------------------------------------------
    a = 100;  a = 100
    function demo(e) {
    function e() {}
    arguments[0] = 2;       //e = 2
    document.write(e);  //输出function () {}
    if(a) {
    var b = 123;
    function c() {}
    }
    var c;
    a = 10;   //a = 10
    var a;
    document.write(b); //输出b = undefined
    f = 123;        //f = 123
    document.write(c); //输出c = function () {}
    document.write(a); //输出a = 10
    }
    var a;
    demo(1);
    document.write(a);  //输出a = 100 找的是全局的，不能引用函数里的
    document.write(f);  //输出f = 123

    // GO{
    //     a : undefined,
    //     f : undefined,
    //     demo : function () {}
    // }
    // AO{
    //     e : function e() {},
    //     a : undefined,
    //     c : function c() {},
    //     b : undefined,
    //
    // }


</script>
<script id="闭包例子" type="text/html">
    function a() {
    var num = 100;
    function b() {
    num ++;
    console.log(num);
    }
    return b;
    }
    var demo = a();
    demo();
    demo();

    // a : GO
    // a : AO
    //     GO
    // b : AO
    //     GO

    function javase.test() {
    var num = 100;
    function a() {
    num ++;
    console.log(num);
    }
    function b() {
    num --;
    console.log(num);
    }
    return [a,b];
    }
    var Arr = javase.test();
    Arr[0]();//101
    Arr[1]();//101-1=100
    //a和b同享一个AO，a改变了之后AO里的值也改变了

    //立即执行函数,执行完立即释放，只保留结果(function ()


    (function (a,b,c) {
    return d = a + b + c;
    }(1,2,3))
    //函数表达式可以被立即执行
    //函数表达式不行
    var b = function javase.test () {
    console.log(b);
    }();//可以
    function javase.test() {
    console.log(b);
    }();//不行
    + function  javase.test(){
    console.log(b);
    }();//可以,+代表表达式
</script>
<script id="" type="text/html">
    function   javase.test(){
    var arr = [];
    for(var i = 0;i < 10;i ++){
    (function (j) {
    document.write(j + "");
    }(i))
    }return arr;
    }
    var x = 1;
    if(function f() {}) {       //function执行之后销毁了
    x += typeof f;      //未经声明的变量放到F里面不报错，typeof 返回的是string类型，所以会拼接
    }
    console.log(x);
</script>
<script id="对象" type="text/html">
    var yzy = {
    name: 'yzy',
    age: 21,
    sex: 'man',
    gf : 'tt',
    local : 'sx',
    wife : '',
    sport: function () {
    console.log('soccer');
    this.health++;
    },
    drink: function () {
    console.log('cola');
    this.health--;
    },
    marriy : function () {
    this.wife = this.gf;
    this.gf = '';
    },
    divorce : function () {
    this.wife = '';
    }
    }//yzy.wife = 'yzy';

    //对象的创建方法
    var obj = {}
    //2.构造函数
    //1).系统自带的构造函数 new Object()
    //创建对象，后天可以增加属性
    var obj = new Object ();
    obj.name = 'abc';
    obj.sex = 'man';
    //2).自定义,严格按照大驼峰命名规则 TheFistName
    function Car(color) {
    this.color = color;     //该属性可以选配
    this.name = 'BMW';
    this.height = 1400;
    this.lang = '4900';
    this.weight = 10000;
    this.health = 100;
    this.run = function () {
    this.health --;
    }
    }
    var car = new Car('green');
    var car1 = new Car('red');
    car.name = "benz";
    car1.name = 'dazhong';

    //构造函数内部原理
    //1.在函数体最前面隐式的加上this = {}
    //2.执行this.xxx = xxx
    //3.隐式的返回this
    function Student(name,age,sex){
    //var this = {
    // name : ''
    // sex : ''
    // age : ''
    // ....}
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.grade = 2017;
    //若return 123;这种原始值，构造函数不予理会
    //return this；
    }
    var student1 = new Student('yy',17,'man');

    function Person(name,height) {
    this.aa = 0;
    this.name = name;
    this.height = height;
    this.say = function say() {
    this.aa ++;
    }
    }
    var person1 = new Person();   //undefined
    var person2 = new Person('li',175);
    person2.say();  //aa=1
    var person3 = new Person('tt',190);
    //person.aa = 0;

    //person1.say();

    //包装类
    var num = new Number(123);
    var str = new String('hhh');
    var boolean = new Boolean(true);


</script>
<script id="草稿本" type="text/html">
    //当前字符位的unicode > 255，那么该字符字节长度位2
    // <= 255为 1
    var str = 'asdss,.;尹';

    function byte(str) {
    var lengths = str.length;
    for (var i = 0;i < str.length;i ++) {
    if(str.charCodeAt(i) > 255){
    lengths ++;
    }
    }return lengths;
    }

    console.log(byte(str));
</script>
<script id="原型" type="text/html">
    //原型，也是个对象，原型可以消除冗余，把不变的属性赋给祖先----------------------------------------
    Person.prototype = {};
    Person.prototype.name = 'yy';//祖先有这个属性
    Person.prototype.color = 'yellow';

    Person.prototype = {                        //也可以这么写
    name : 'yy',
    color : 'yellow',
    say : function () {
    console.log('hh')
    }
    }

    function  Person(name,car){
    this.name = name;           //如果对象中也有属性，那么就选择自己的属性
    this.car = car;
    //this.color = 'yellow';      //不变的属性可以转移到祖先，减少冗余
    }

    var person = new Person();//person中不会有那么这个属性但是person.name 中会有，相当于继承了祖先的属性
    var person2 = new Person('yyy','bmw');
    delete person.color ;           //返回true，但是不会消失，因为person没有这个属性，电脑不会返回false，但是不会删除。
    Person.prototype.name = 'ss';      //前后有相同的原型属性取后者
    Person.prototype = {                //但是这种写法并不会覆盖，person2.prototype.name = ‘ss’
    name : 'cherry'                 //prototype ={}相当于创建了个新对象
    }

    var obj = {
    name : 'aaa0'
    }
    person.__proto__ = obj;     //      这个会替换原型



    Student.prototype.name = 'yzy';
    function Student(){
    //this.name = 'yy';
    }
    var stu = new Student();


    //原型链-------------------------------------------------------------------------------------------
    Grand.prototype.lastName = 'yin';
    function Grand(){
    this.age = 66;
    this.old = function eld() {
    console.log(this.age);
    }
    }
    var grand = new Grand ;
    Father.prototype = grand;
    function    Father(){
    this.age = 48;
    }
    var father  = new Father;
    Son.prototype = father;
    function Son(){
    this.age = 21;
    }
    var son = new Son ();


    //Object.create(原型)
    //绝大多数对象最终会继承自Object.prototype,但是有例外:Object.create(null)
    var obj  = {
    name : '22',
    age : 22
    }
    var obj1 = Object.create(obj);

    Tea.prototype.name = 'cha';
    function Tea() {
    this.age = 100;
    }
    var tea = Object.create(Tea.prototype);
    var obj2 = Object.create(null);



</script>
<script id="call" type="text/html">
    //可正常计算的范围，小数点前16位，小数点后16位

    //   call/apply,作用：改变this指向，传参不同

    function Person(name,age) {
    //this == obj;
    this.name = name;
    this.age = age;
    }
    var person = new Person('y',22);
    var obj = {
    }
    Person.call(obj,'y',40);//obj = {name : 'y' ,age : 40}，添加对象会使this.name发生改变obj.name

    //Person.call() = Person();  call不添加对象没有任何区别
    function Man(name,age,sex) {
    this.name = name;
    this.age = age;
    this.sex = sex;
    }
    function Student(name,age,sex,tel,grade) {
    Man.call(this,name,age,sex);
    this.tel = tel;
    this.grade = grade;
    }
    var man = new Man();
    var student = new Student('yzy',22,'man',182,'大三');


    function    Bedroom(bsize,bnum){
    this.bsize = bsize
    this.bednum = bnum;
    }
    function  Livingroom(lsize){
    this.lsize = lsize;
    }
    function  Washroom(wsize){
    this.wsize = wsize;
    }
    function  House(bsize,bnum,lsize,wsize){
    //call需要把实参按照形参的个数传进去
    //apply需要传一个arguement
    Bedroom.apply(this,[bsize,bnum]);
    Livingroom.call(this,lsize);
    Washroom.call(this,wsize);
    }
    var house = new House(22,21,10);



</script>
<script id="共享原型" type="text/html">
    Father.prototype.lastName = 'yin';
    function Father(){}
    function  Son(){}
    // Son.prototype = Father.prototype;

    //继承-----------------------------------------------
    // function extend(){}
    // function inherit(Target,Origin){//使Target和Origin的原型绑定
    //     Target.prototype = Origin.prototype;
    // }
    // inherit(Son,Father);//先继承后用，
    // //Son.prototype.sex = 'man';       //这边会使father的原型也有该值
    // var son = new Son();
    // //console.log(son.lastname);
    // var father = new Father();

    //圣杯模式----------------------------------------------
    function inherit(Target,Origin){
    function F(){}   //充当中间层
    F.prototype = Origin.prototype;
    Target.prototype = new F();
    Target.prototype.constructor = Target;  //原本Target的constructor 为 Origin
    Target.prototype.uber = Origin.prototype()  //储存超级父类
    }
    inherit(Son,Father);
    var son = new Son();
    var father = new Father();
</script>
<script id="命名对象" type="text/html">
    //init的英文意思是初始化
    var init = (function () {

    var name = 'abc';

    function callName() {
    console.log(name);
    }
    return function (){
    callName();
    }
    }())
    //init();

    var initDeng = (function () {

    var name = 123;
    function callName () {
    console.log(name);
    }
    return function () {
    callName();
    }
    }())
    initDeng();

</script>
</body>
</html>
